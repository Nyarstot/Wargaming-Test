# Тест на вакансию Junior programmer (Python, C++) в Wargaming
---

- ## Задание №1

  ### Задача:
    > На языке Python или С/С++, написать алгоритм (функцию) определения четности целого числа, 
    > который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
    > Объяснить плюсы и минусы обеих реализаций.
    > <br><br>
    >  ***Python example:***
    >  ```python
    >   def isEven(value):return value%2==0
    >   ```
    >   <br><br>
    >   ***C/C++ example:***
    >   ```C++
    >    bool isEven(int value){return value%2==0;}
    >   ```
    >   <br><br>

  ### Решение: <br>
    Для решения задачи была написана следующая функция:
    
    ```C++
    bool isEven(int value) { return (value >> 1) << 1 == value; }
    ```
    
    Принцип работы данной функции завязан на факте того, что последний бит чётного числа всегда равен нулю.
    Это значит, что при побитовом сдвиге влево а затем снова вправо - число не измениться и при сравнении
    с изначальным даст истину. В то время как последний бит нечётного числа, равный единице,
    обратится в ноль и при сравнении выдаст ложь. <br>
    
    Например:
    
    ```ASM
    isEven(24):
      dec(24) = bin(00011000)
      00011000 >> 1 = 00001100
      00001100 << 1 = 00011000
      00011000 == dec(24)
      true
     ```
     
     ```ASM
     isEven(25):
      dec(25) = bin(00011001)
      00011001 >> 1 = 00001100
      00001100 << 1 = 00011000
      00011000 == dec(25)
      false
     ```
  ### Выводы: <br>
    
    Для подведения итогов проведём бенчмарк обеих функций. <br>
    
    ![clang_tests](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/clang.jpg)
    > Clang 13.0
    <br>
    
    ![gcc_test](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/gcc.jpg)
    > GCC 11.2
    <br>
    
    Как видно из диаграмм - оба метода имеют "взаимные" плюсы и минусы. Функция, принцип работы которой заключается 
    в нахождении остатка от числа, быстрее работает на компиляторе Clang, что является плюсом, однако медленнее на  
    компиляторе GCC, что, в свою очередь - минус. Функция же написанная мной, соответственно, быстрее работает на GCC 
    и медленнее на Clang. Однако есть так же субъективный, но, всё ещё, немаловажный фактор - удобство. Деление с остатком 
    для определения чётности/нечётности числа куда более интуитивно понятна для любого человека, что определённо является плюсом.
    
    <br>
    
    |            | Clang | GCC | Удобство|
    |------------|-------|-----|---------|
    | MY_IS_EVEN |   -   |  +  |    -    |
    | WG_IS_EVEN |   +   |  -  |    +    |
    
- ## Задание №2
- ## Задание №3
