# Тест на вакансию Junior programmer (Python, C++) в Wargaming
---

- ## Задание №1

  ### Задача:
    > На языке Python или С/С++, написать алгоритм (функцию) определения четности целого числа, 
    > который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
    > Объяснить плюсы и минусы обеих реализаций.
    > <br><br>
    >  ***Python example:***
    >  ```python
    >   def isEven(value):return value%2==0
    >   ```
    >   <br><br>
    >   ***C/C++ example:***
    >   ```C++
    >    bool isEven(int value){return value%2==0;}
    >   ```
    >   <br><br>

  ### Решение: <br>
    Для решения задачи была написана следующая функция:
    
    ```C++
    bool isEven(int value) { return (value >> 1) << 1 == value; }
    ```
    
    Принцип работы данной функции завязан на факте того, что последний бит чётного числа всегда равен нулю.
    Это значит, что при побитовом сдвиге влево а затем снова вправо - число не измениться и при сравнении
    с изначальным даст истину. В то время как последний бит нечётного числа, равный единице,
    обратится в ноль и при сравнении выдаст ложь. <br>
    
    Например:
    
    ```ASM
    isEven(24):
      dec(24) = bin(00011000)
      00011000 >> 1 = 00001100
      00001100 << 1 = 00011000
      00011000 == dec(24)
      true
     ```
     
     ```ASM
     isEven(25):
      dec(25) = bin(00011001)
      00011001 >> 1 = 00001100
      00001100 << 1 = 00011000
      00011000 == dec(25)
      false
     ```
  ### Выводы: <br>
    
    Для подведения итогов проведём бенчмарк обеих функций. <br>
    
    ![clang_tests](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/clang.jpg)
    > Clang 13.0
    <br>
    
    ![gcc_test](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/gcc.jpg)
    > GCC 11.2
    <br>
    
    Как видно из диаграмм - оба метода имеют "взаимные" плюсы и минусы. Функция, принцип работы которой заключается 
    в нахождении остатка от числа, быстрее работает на компиляторе Clang, что является плюсом, однако медленнее на  
    компиляторе GCC, что, в свою очередь - минус. Функция же написанная мной, соответственно, быстрее работает на GCC 
    и медленнее на Clang. Однако есть так же субъективный, но, всё ещё, немаловажный фактор - удобство. Деление с остатком 
    для определения чётности/нечётности числа куда более интуитивно понятна для любого человека, что определённо является плюсом.
    
    <br>
    
    |            | Clang | GCC | Удобство|
    |------------|-------|-----|---------|
    | MY_IS_EVEN |   -   |  +  |    -    |
    | WG_IS_EVEN |   +   |  -  |    +    |
    
- ## Задание №2
  
  ### Задача: <br>
    > На языках Python(2.7) и/или С++, написать минимум по 2 класса реализовывающих циклический буфер. 
    > Объяснить плюсы и минусы каждой реализации.
  
  ### Решение: <br>
    Решение, как и требуется в задание представленно в двух вариантах: <br>
    
    [**1. Динамический кольцевой буфер**](https://github.com/Nyarstot/Wargaming-Test/blob/main/Wargaming-Test/ring_buffers/ring_buffer.h) <br>
    [**2. Статический кольцевой буфер**](https://github.com/Nyarstot/Wargaming-Test/blob/main/Wargaming-Test/ring_buffers/static_ring.h) <br>
    
    Основополагающим фактором в производительности кольцевого буфера является метод добавления в него элементов, который, в данном случае, 
    осуществляется двумя разными способами - через проверку индекса головного указателя на выход за границы определяемой для кольца области 
    в динамическом массиве и через деление с остатком предполагаемого следящего индекса на размер массива. <br>
    
    В случае с динамическим массивом используется проверка индекса, что позволяет не производить никаких расчётов, а лишь изменить 
    текущее значение головного указателя на нулевой элемент массива по достижении элемента buffer[size], тогда как в случае со 
    статическим массивом используется добавление элемента через деление индекса с остатком, что, разумеется, замедляет работу буфера  
    и является его большим минусом. <br>
    
    Например, даже для кольца с размерностью равной 5 характерна следующая разность во времени: <br>
    
    |         | ring_buffer | static_ring |
    |---------|-------------|-------------|
    | push    |  2.35E-08   |  2.43E-08   |
    | pop     |  1.86E-08   |  2.04E-08   |
    | emplace |  6.12E-08   |  2.96E-08   |

    \*ring_buffer - динамический кольцевой буфер. <br>
    \*\*static_buffer - статический кольцевой буфер. <br>
    \*\*\*Полученное время указано в секундах. <br>

    Здесь же можно заметить проблему динамического массива, связанную с аллокацией памяти - процедура emplace занимает аж в три раза больше времени,
    чем та же процедура на статическом массиве. Всё дело в том, как устроин метод emplace внутри структур. <br>
    
    > ring_buffer.h
    ```C++
    template <typename... _Va>
	  void emplace(_Va&&... args)
	  {
		  if (full()) {
			  throw std::logic_error("Buffer is full now");
		  }

		  m_Counter++;
		  _Alty_traits::construct(m_Alloc, m_Buffer + m_Head, std::forward<_Va>(args)...);
		  m_Head = next_index(m_Head, m_Size);
	  }
    ```
    <br>
    
    > static_ring.h
    ```C++
    template<typename _Va>
    void emplace_back(_Va&& args)
    {
        m_Counter++;
        m_Buffer[m_Head] = std::forward<_Va>(args);
        m_Head = next_index(m_Head, _Sze);

        if (full()) { m_Tail = next_index(m_Tail, _Sze); }
        if (m_Counter < _Sze) { m_Counter++; }
    }
    ```
    
    Как мы видим, в первом случае используется allocator_traits::construct, что гарантирует надёжность в работе, однако замедляет
    время выполнения. <br>
    
    Перейдём от добавления элементов к реализации итерации по элементам в буферах. В динамическом буфере считается, что буфер 
    заполнен, когда хвостовой указатель отстаёт на один элемент от головного указателя. Итератор в динамическом кольце просто проходит
    от головного указателя до хвостового, что не позволяет обратиться к хвостовому элементу, поскольку выполняется условие достижения хвоста.
    В свою очередь это является минусом, поскольку если последний элемент всё-таки нужен, потребуется дополнительное постусловие для обращения к нему.<br>
    
    Для статического же буфера выполнена несколько другая логика итерации. В статическом буфере считается, что буфер заполнен, когда счётчик элементов
    равен размеру буфера, что позволяет организовать ещё один счётчик элементов уже внутри итератора и ориентироваться на его равенство счётчику в буфере.
    В таком случае все элементы кольца становятся доступны даже при полной заполненности.<br>
    
    Заключающим же фактором, как водится, субъективным, является факт того что, в динамическом массиве не разрешена перезапись элементов при условии, 
    что хвост  догнал голову. Должен быть обязательно выполнен метод pop() для дальнейшей перезаписи. В статическом же массиве перезапись разрешена и 
    по достижении головы,  хвост начнёт двигать голову, перезаписывая старые элементы на новые, что для кого-то будет являться плюсом, для кого-то - минусом.
    
   ### Краткий итог: <br>
    Исходя из всего вышеописанного можно сказать, что динамический кольцевой буфер более быстрый, однако менее стабильный при работает с итератором, 
    тогда как  статический массив работает медленнее, но стабильно - итератор справляется в любом случае.
    
- ## Задание №3
  ### Задача:
     > На языке Python или С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.
     > Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).
     > Объяснить почему вы считаете, что функция соответствует заданным критериям.
     
     Стоит начать с того, что такая вариативность сортировок, которую мы имеем на сегодняшний день, появилась не просто так и некоторые из них
     предназначены для решения специфических задач в специфичных условиях и т.п. Поэтому, я не уверен, что выделять какую-то одну конкретную
     является корректным, однако, если опираться на некий средний показатель, то я бы выделил быструю сортировку:
     
     > q_Sort.h
     ```C++
     void q_Sort(int* arr, int left, int right)
     {
        int l = left;
        int r = right;
        int pivot = arr[(l + r) / 2];

        while (l <= r) 
        {
            while (arr[l] < pivot) {
                l++;
            }
            while (arr[r] > pivot) {
                r--;
            }

            if (l <= r) {
                std::swap(arr[l], arr[r]);
                l++; r--;
            }
        }

        if (r > left) {
            q_Sort(arr, left, r);
        }
        if (l < right) {
            q_Sort(arr, l, right);
        }
     }
     ```
     <br>
     
     Для того чтобы определиться с выбором, стоит взглянуть на графики с данными о скорости работы сортировок на рзличных наборах данных: <br>
     
     ![small_random](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/small_rand.gif)
     > Малые размерности, случайные значения

     <br>
     
     ![small_random_sort](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/small_part_sort.gif)
     > Малые размерности, частично отсортированные значения

     <br>
     
     ![big_ranodm](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/big_rand.gif)
     > Большие размерности, сулчайные значения

     <br>
     
     ![big_random_sort](https://github.com/Nyarstot/Wargaming-Test/blob/main/tests/graphs/big_part_sort.gif)
     > Большие размерности, частично отсортированные значения

     <br>
     
     На графиках видно, что быстрая сортировка лидирует во всех проведённых тестах. Есть сортировки, которые лучше работают на малых объёмах данных,
     нежели на больших, такие как сортировка выбором, например, которая на малых данных почти не уступает быстрой сортировке, и наоборот, которые лучше
     работают на большом объёме данных (пирамидальная), но если называть что-то более менее универсальное, то это определённо будет быстрая сортировка.
     Именно по этому я выбрал её и считаю, что она отвечает заданным критериям.
